//#-p redstone_lamp 0 -print
/// -161 95 -561

//<Defines
DEFINE $ObjA$ scoreboard objectives add
DEFINE $ObjR$ scoreboard objectives remove
DEFINE $TeamO$ scoreboard teams option
DEFINE $Style$ 16 16 0
DEFINE $s$ minecraft:
DEFINE $SA$ x=#,y=#,z=#,dx=#,dy=#,dz=#

DEFINE Deactivate fill |0| stonebrick 0
DEFINE Activate fill |0| redstone_block 0
DEFINE ScTG scoreboard players tag
DEFINE ScOP scoreboard players operation
DEFINE RevST scoreboard players tag @a[|0|] remove |0|
DEFINE SetblockTestfor setblock ~ ~ ~ repeating_command_block 13 replace {TrackOutput:0b,auto:1b}
DEFINE NumberAdd |0| Number = |0|
DEFINE NumberObjAdd scoreboard objectives add Number dummy

FUNC RotationDisplay
	ScOP YRotation TF2Disp|0| = @e[TF2Projectile,TF2prst=0] TF2YR
	ScOP XRotation TF2Disp|0| = @e[TF2Projectile,TF2prst=0] TF2XR
END
FUNC CalcDisplay
	ScOP SinT Display = @e[TF2Projectile,type=ArmorStand,TF2prst=0,c=1] TF2SinT
	ScOP CosT Display = @e[TF2Projectile,type=ArmorStand,TF2prst=0,c=1] TF2CosT
	ScOP SinP Display = @e[TF2Projectile,type=ArmorStand,TF2prst=0,c=1] TF2SinP
	ScOP CosP Display = @e[TF2Projectile,type=ArmorStand,TF2prst=0,c=1] TF2CosP
END
FUNC XYZDisplay
	ScOP X Display = @e[TF2Projectile,type=ArmorStand,TF2prst=0,c=1] TF2X
	ScOP Y Display = @e[TF2Projectile,type=ArmorStand,TF2prst=0,c=1] TF2Y
	ScOP Z Display = @e[TF2Projectile,type=ArmorStand,TF2prst=0,c=1] TF2Z
END

DEFINE $ProjectileEnd$ minecraft:kill @e[TF2Projectile]
//>

//<Notes
FUNC Func_UselessNotesLol
Sine approximation
https://www.wolframalpha.com/input/?i=sine+approximation

https://www.desmos.com/calculator

http://i.imgur.com/SqHQoin.png
Bhaskara's sine approximation overtop a sine graph
Effective between 0 - 180

http://i.imgur.com/yXYmio1.png
Bhaskara's sine approximation (translated to be a cosine approximation) overtop a cosine graph
Effective between -90 to 90


https://upload.wikimedia.org/wikipedia/commons/e/e7/Simple_raycasting_with_fisheye_correction.gif
Raycasting gif: pretty awesome actually

http://mathworld.wolfram.com/SphericalCoordinates.html
Spherical coordinate to Cartesian coordinate formulas

Vy-0.5g*t^2

Vy+ -4.905(t^2)/400


Practically every other video I've seen on the same topic uses a program called "Command block directions", where they use multiple singular commands that activate depending on where you look. Not only is this highly inaccurate, but the maximum accuracy this can have is a 1 degree precision. They also have to summon an existing projectile in Minecraft, such as an arrow. This means adding custom gravity, bouncing mechanics, and many other variables cannot be controlled. It is also much more massive, lag inducing, and just plain horrible to use compared to this.

Also, the video that GamerGuppy shows has a mistake in the taylor series. He describes it as fractional exponents, although he mistakes the denominator as the denominator of the exponent rather than the entire number.

https://en.wikipedia.org/wiki/CORDIC
Something to do with how calculators compute trigonometric functions
END
//>

//<To Do 
FUNC Func_ToDoThings
Mandatory Changes:
	-
	
General Changes:
	-Different velocity changes on different surfaces
	-Breaking glass if hit hard enough
	
	-Possibly have rolling calc with a percentage and a constant if percentage doesn't work
	
	
	
Bugs:
	-Constantly bounces when roll is disabled -- Will not change
	-Y vector (height) increases / decreases with each bounce
		-Change by saving the Y vector on bounce
		-Doesn't work since the bounce can happen at different Y coordinates
		-
	
Implemented Changes:
	-TF2XR and TF2YR are now conserved (edited calculating sin/cos) -- WORKS
	-Removed gravity calc -- WORKS
	-Rolling is enabled IF: -- WORKS
		-Y vector is less than RollVelocityCheck
		-Bounce and gravity are on
		-There is no air above / below
	-Low velocity check to prevent rolling and other movement to happen at low velocities -- FIX
		-Only activated when rolling is present
	-Fix rolling check to be in depth as when rolling is enabled -- WORKS
	-Change percent rolling calc to use abs value -- WORKS
	-Rolling with negative gravity = stick to the ceiling lol -- WORKS
	
Bug fixes:
	-Deceleration is weird - change to removing a percentage of spd instead of const -- Changed to percentage, check if this works -- NEEDSTEST
	
	-Bounce works when turned off while rolling -- NEEDSTEST
		-Fixed with adding a bounce check
END
//>


//<Add objectives + teams
:CBPObjA PULSE $Style$
///Objectives
USE $ObjA$
	TF2CS stat.useItem.minecraft.carrot_on_a_stick TF2 Carrot Stick
	TF2CD dummy TF2 Cooldown
	TF2prst dummy TF2 Projectile State
	TF2time dummy TF2 Time in air
	TF2GravT dummy TF2 Gravity Time
	TF2IA dummy TF2 Projectile In Air
	TF2Rad dummy TF2 Velocity Radius
	TF2PID dummy TF2 Player ID
	TF2timeC dummy TF2 Time Calc
	TF2IAC dummy TF2 In Air Check
	
	TF2XR dummy TF2 X Axis Rotation
	TF2YR dummy TF2 Y Axis Rotation
	TF2Nom dummy TF2 Numerator
	TF2Denom dummy Denominator
	TF2Neg dummy TF2 Negative
	TF2Rev dummy TF2 Reverse
	TF2RevC dummy TF2 Reverse Calc
	TF2SinT dummy sin Theta Azimuthal
	TF2CosT dummy cos Theta Azimuthal
	TF2SinP dummy sin Phi Elevation
	TF2CosP dummy cos Phi Elevation
	TF2X dummy TF2 X Motion
	TF2Y dummy TF2 Y Motion
	TF2Z dummy TF2 Z Motion
	TF2XT dummy TF2 X Teleport
	TF2YT dummy TF2 Y Teleport
	TF2ZT dummy TF2 Z Teleport
	TF2LVC dummy TF2 Low Velocity Check
	TF2GenC dummy TF2 General Check
	TF2Roll dummy TF2 Roll State
	TF2RollC dummy TF2 Roll Calc
	TF2RollCX dummy TF2 Roll Calc X
	TF2RollCZ dummy TF2 Roll Calc Z
	
	TF2NAX dummy TF2 Next Air X
	TF2NAY dummy TF2 Next Air Y
	TF2NAZ dummy TF2 Next Air Z
	TF2NADPX dummy TF2 Air Diagonal Pos X
	TF2NADPY dummy TF2 Air Diagonal Pos Y
	TF2NADPZ dummy TF2 Air Diagonal Pos Z
	TF2NADNX dummy TF2 Air Diagonal Neg X
	TF2NADNY dummy TF2 Air Diagonal Neg Y
	TF2NADNZ dummy TF2 Air Diagonal Neg Z
	
	TF2Edit dummy Edit Constant Values
UNUSE

///Constant values
Cooldown TF2Edit = 12
Bounce TF2Edit = 1
Velocity TF2Edit = 11
Time TF2Edit = 100
Gravity TF2Edit = 400000
RollVelocityCheck TF2Edit = 500000
RollCoefficient TF2Edit = 25
FrictionNumXZ TF2Edit = 9
FrictionDenXZ TF2Edit = 10
FrictionNumY TF2Edit = 3
FrictionDenY TF2Edit = 4
ProjectileNumber TF2Edit = 0
KillAll TF2Edit = 0
LowVelocityCheck = 50000

///Teams
scoreboard teams add TF2R
scoreboard teams add TF2B
scoreboard teams option TF2R color red
scoreboard teams option TF2B color blue

scoreboard teams join TF2R ProjectileNumber

NumberObjAdd
NumberAdd(1000)
NumberAdd(10)
NumberAdd(-1)
NumberAdd(-4)
NumberAdd(-1000)
//>

//<Remove objectives + teams
:CBPObjR PULSE $Style$
USE $ObjR$
	TF2CS
	TF2CD
	TF2prst
	TF2time
	TF2GravT
	TF2IA
	TF2Rad
	TF2PID
	TF2timeC
	TF2IAC
	
	TF2XR
	TF2YR
	TF2Nom
	TF2Denom
	TF2Neg
	TF2Rev
	TF2RevC
	TF2SinT
	TF2CosT
	TF2SinP
	TF2CosP
	TF2X
	TF2Y
	TF2Z
	TF2XT
	TF2YT
	TF2ZT
	TF2LVC
	TF2GenC
	TF2Roll
	TF2RollC
	TF2RollCX
	TF2RollCZ
	
	TF2NAX
	TF2NAY
	TF2NAZ
	TF2NADPX
	TF2NADPY
	TF2NADPZ
	TF2NADNX
	TF2NADNY
	TF2NADNZ
	
	TF2Edit
UNUSE
scoreboard teams remove TF2R
scoreboard teams remove TF2B
//>


//<General Clock
:CBPMainClock CLOCK $Style$
///Player ID
///Keep in main clock
	@a TF2PID + 0
	@a[TF2PID=0,c=1] PlayerNumber TF2PID + 1
	ScOP @a[TF2PID=0,c=1] TF2PID = PlayerNumber TF2PID
///Weapon Cooldown
	@a TF2CD + 0
	@a[TF2CD>=1] TF2CD - 1
///Projectile Numbers
	ProjectileNumber TF2PID = 0
	@e[TF2Projectile] ProjectileNumber TF2PID + 1
	ScOP ProjectileNumber TF2Edit = ProjectileNumber TF2PID
//>

//<Upon Weapon Fire: Start
:CBPRotations CLOCK $Style$
///Summons armor stand, sets score
/// baby i'm ballin

///	@a[team=TF2r,TF2CS>=1] ~ ~ ~ summon ArmorStand ~ ~ ~ {Marker:1,Invisible:1,Invulnerable:1,NoGravity:1,Small:1,Tags:["TF2Projectile","TF2ProjectileR"]}
///	@a[team=TF2b,TF2CS>=1] ~ ~ ~ summon ArmorStand ~ ~ ~ {Marker:1,Invisible:1,Invulnerable:1,NoGravity:1,Small:1,Tags:["TF2Projectile","TF2ProjectileB"]}
	testfor @a[TF2CS>=1]
	SetblockTestfor
//>

//<Upon Weapon Fire: Summons Armor Stand
	@a[TF2CS>=1,TF2CD=0] summon ArmorStand ~ ~ ~ {Marker:1,Invisible:1,NoGravity:1,Small:1,Tags:["TF2Projectile"]}
	@e[TF2Projectile] TF2prst + 0
	@e[TF2Projectile,TF2prst=0] $s$tp @e[TF2Projectile,TF2prst=0,r=0,c=1] @a[TF2CS>=1,r=1,c=1]
	CONSTART
		@e[TF2Projectile,TF2prst=0] ScOP @e[TF2Projectile,TF2prst=0,c=1,r=1] TF2PID = @a[TF2CS>=1,c=1,r=1] TF2PID
		@e[TF2Projectile,TF2prst=0] ScOP @e[TF2Projectile,TF2prst=0,c=1,r=1] TF2PID = @a[TF2CS>=1,c=1,r=1] TF2PID
		@e[TF2Projectile,TF2prst=0] TF2XR = 0
		@e[TF2Projectile,TF2prst=0] TF2YR = 0
		@e[TF2Projectile,TF2prst=0,rxm=0,rx=90] TF2XR + 90000
	CONEND
//>

//<Upon Weapon Fire: Constant Values
///Cooldown
	ScOP @a[TF2CS>=1,TF2CD=0] TF2CD = Cooldown TF2Edit
	ScOP @e[TF2Projectile,TF2prst=0] TF2Rad = Velocity TF2Edit
//>

//<Upon Weapon Fire: Calculating Angles and reference angle
	$s$tp @e[TF2Projectile,rxm=-90,rx=-1] ~ ~ ~ ~ ~90
	

///XR teleports: 1 degree precision
	LOOP 64 1 / 2
		@e[TF2Projectile,TF2prst=0,rxm=|0|] TF2XR + |0|000
		CONDITION
			$s$tp @e[TF2Projectile,TF2prst=0,rxm=|0|] ~ ~ ~ ~ ~-|0|
	END
///YR teleports: 1 degree precision
	LOOP 256 1 / 2
		@e[TF2Projectile,TF2prst=0,rym=|0|] TF2YR + |0|000
		CONDITION
			$s$tp @e[TF2Projectile,TF2prst=0,rym=|0|] ~ ~ ~ ~-|0| ~
	END

///XR teleports: 0.001 degree precision
	LOOP 512 1 / 2
		$s$tp @e[TF2Projectile,TF2prst=0] ~ ~ ~ ~ ~-DIV(|0|;1000.0)
		@e[TF2Projectile,TF2prst=0,rx=0,rxm=0] TF2XR + |0|
		$s$tp @e[TF2Projectile,TF2prst=0,rxm=89] ~ ~ ~ ~ ~DIV(|0|;1000.0)
	END

///YR teleports: 0.001 degree precision
	LOOP 512 1 / 2
		$s$tp @e[TF2Projectile,TF2prst=0] ~ ~ ~ ~-DIV(|0|;1000.0) ~
		@e[TF2Projectile,TF2prst=0,rym=0,ry=0] TF2YR + |0|
		$s$tp @e[TF2Projectile,TF2prst=0,rym=359] ~ ~ ~ ~DIV(|0|;1000.0) ~
	END
/// RotationDisplay(1)

///	Reference angle - store sin values instead
///	@e[TF2Projectile,TF2prst=0] ScOP @e[c=1,r=1,TF2Projectile,TF2prst=0] TF2YRef = @e[c=1,r=1,TF2Projectile,TF2prst=0] TF2YR
///	ScOP @e[TF2Projectile,TF2prst=0,TF2YRef<=-1] TF2YRef *= -1 Number
///	ScOP @e[TF2Projectile,TF2prst=0,TF2YRef>=270000<=360000] TF2YRef *= -1 Number
///	@e[TF2Projectile,TF2prst=0,TF2YRef>=-360000<=-270000] TF2YRef + 360000
///	@e[TF2Projectile,TF2prst=0,TF2YRef>=180000<=270000] TF2YRef - 180000
///	ScOP @e[TF2Projectile,TF2prst=0,TF2YRef>=90000<=180000] TF2YRef *= -1 Number
///	@e[TF2Projectile,TF2prst=0,TF2YRef>=-180000<=-90000] TF2YRef + 180000
//>

//<Upon Weapon Fire: Calculates sin and cos values	
///Theta: Rotation θ
///Phi: Elevation φ

///	Sin(φ)
	@e[TF2Projectile,TF2prst=0] TF2Nom = 180000
	@e[TF2Projectile,TF2prst=0] ScOP @e[c=1,r=1,TF2Projectile,TF2prst=0] TF2Nom -= @e[c=1,r=1,TF2Projectile,TF2prst=0] TF2XR
	ScOP @e[TF2Projectile,TF2prst=0] TF2Nom /= -1000 Number
	@e[TF2Projectile,TF2prst=0] ScOP @e[c=1,r=1,TF2Projectile,TF2prst=0] TF2Nom *= @e[c=1,r=1,TF2Projectile,TF2prst=0] TF2XR
	@e[TF2Projectile,TF2prst=0] ScOP @e[c=1,r=1,TF2Projectile,TF2prst=0] TF2Denom = @e[c=1,r=1,TF2Projectile,TF2prst=0] TF2Nom
	@e[TF2Projectile,TF2prst=0] TF2Denom + 40500000
	ScOP @e[TF2Projectile,TF2prst=0] TF2Denom /= 1000 Number
	ScOP @e[TF2Projectile,TF2prst=0] TF2Nom *= -4 Number
	@e[TF2Projectile,TF2prst=0] ScOP @e[c=1,r=1,TF2Projectile,TF2prst=0] TF2Nom /= @e[c=1,r=1,TF2Projectile,TF2prst=0] TF2Denom
	@e[TF2Projectile,TF2prst=0] ScOP @e[c=1,r=1,TF2Projectile,TF2prst=0] TF2SinP = @e[c=1,r=1,TF2Projectile,TF2prst=0] TF2Nom
/// RotationDisplay(2)

///	Cos(φ)
	@e[TF2Projectile,TF2prst=0] TF2Neg = 1
	@e[TF2Projectile,TF2prst=0,TF2XR>=90000] TF2Neg = -1
	@e[TF2Projectile,TF2prst=0,TF2XR>=90000] TF2XR - 180000
	@e[TF2Projectile,TF2prst=0] ScOP @e[c=1,r=1,TF2Projectile,TF2prst=0] TF2Denom = @e[c=1,r=1,TF2Projectile,TF2prst=0] TF2XR
	ScOP @e[TF2Projectile,TF2prst=0] TF2Denom /= 10 Number
	@e[TF2Projectile,TF2prst=0] ScOP @e[c=1,r=1,TF2Projectile,TF2prst=0] TF2Denom *= @e[c=1,r=1,TF2Projectile,TF2prst=0] TF2Denom
	@e[TF2Projectile,TF2prst=0] ScOP @e[c=1,r=1,TF2Projectile,TF2prst=0] TF2Nom = @e[c=1,r=1,TF2Projectile,TF2prst=0] TF2Denom
	@e[TF2Projectile,TF2prst=0] TF2Denom + 324000000
	ScOP @e[TF2Projectile,TF2prst=0] TF2Nom *= -4 Number
	@e[TF2Projectile,TF2prst=0] TF2Nom + 324000000
	ScOP @e[TF2Projectile,TF2prst=0] TF2Denom /= 1000 Number
	@e[TF2Projectile,TF2prst=0] ScOP @e[c=1,r=1,TF2Projectile,TF2prst=0] TF2Nom /= @e[c=1,r=1,TF2Projectile,TF2prst=0] TF2Denom
	@e[TF2Projectile,TF2prst=0] ScOP @e[c=1,r=1,TF2Projectile,TF2prst=0] TF2CosP = @e[c=1,r=1,TF2Projectile,TF2prst=0] TF2Nom
	@e[TF2Projectile,TF2prst=0] ScOP @e[c=1,r=1,TF2Projectile,TF2prst=0] TF2CosP *= @e[c=1,r=1,TF2Projectile,TF2prst=0] TF2Neg
/// RotationDisplay(3)

///	Sin(θ)
	@e[TF2Projectile,TF2prst=0] ScOP @e[c=1,r=1,TF2Projectile,TF2prst=0] TF2Nom = @e[c=1,r=1,TF2Projectile,TF2prst=0] TF2YR
	@e[TF2Projectile,TF2prst=0] TF2Neg = -1
	@e[TF2Projectile,TF2prst=0,TF2Nom>=180000=<360000] TF2Neg = 1
	@e[TF2Projectile,TF2prst=0,TF2Nom>=180000=<360000] TF2Nom - 180000
	@e[TF2Projectile,TF2prst=0] ScOP @e[c=1,r=1,TF2Projectile,TF2prst=0] TF2Denom = @e[c=1,r=1,TF2Projectile,TF2prst=0] TF2Nom
	ScOP @e[TF2Projectile,TF2prst=0] TF2Nom *= -1 Number
	@e[TF2Projectile,TF2prst=0] TF2Nom + 180000
	ScOP @e[TF2Projectile,TF2prst=0] TF2Nom /= -1000 Number
	@e[TF2Projectile,TF2prst=0] ScOP @e[c=1,r=1,TF2Projectile,TF2prst=0] TF2Nom *= @e[c=1,r=1,TF2Projectile,TF2prst=0] TF2Denom
	@e[TF2Projectile,TF2prst=0] ScOP @e[c=1,r=1,TF2Projectile,TF2prst=0] TF2Denom = @e[c=1,r=1,TF2Projectile,TF2prst=0] TF2Nom
	ScOP @e[TF2Projectile,TF2prst=0] TF2Nom *= -4 Number
	@e[TF2Projectile,TF2prst=0] TF2Denom + 40500000
	ScOP @e[TF2Projectile,TF2prst=0] TF2Denom /= 1000 Number
	@e[TF2Projectile,TF2prst=0] ScOP @e[c=1,r=1,TF2Projectile,TF2prst=0] TF2Nom /= @e[c=1,r=1,TF2Projectile,TF2prst=0] TF2Denom
	@e[TF2Projectile,TF2prst=0] ScOP @e[c=1,r=1,TF2Projectile,TF2prst=0] TF2SinT = @e[c=1,r=1,TF2Projectile,TF2prst=0] TF2Nom
	@e[TF2Projectile,TF2prst=0] ScOP @e[c=1,r=1,TF2Projectile,TF2prst=0] TF2SinT *= @e[c=1,r=1,TF2Projectile,TF2prst=0] TF2Neg
/// RotationDisplay(4)

///	Cos(θ)
	@e[TF2Projectile,TF2prst=0] TF2Neg = 1
	@e[TF2Projectile,TF2prst=0,TF2YR>=90000<=270000] TF2Neg = -1
	@e[TF2Projectile,TF2prst=0,TF2YR>=90000<=270000] TF2YR - 180000
	@e[TF2Projectile,TF2prst=0,TF2YR>=270000<=360000] TF2YR - 360000
	@e[TF2Projectile,TF2prst=0] ScOP @e[c=1,r=1,TF2Projectile,TF2prst=0] TF2Denom = @e[c=1,r=1,TF2Projectile,TF2prst=0] TF2YR
	ScOP @e[TF2Projectile,TF2prst=0] TF2Denom /= 10 Number
	@e[TF2Projectile,TF2prst=0] ScOP @e[c=1,r=1,TF2Projectile,TF2prst=0] TF2Denom *= @e[c=1,r=1,TF2Projectile,TF2prst=0] TF2Denom
	@e[TF2Projectile,TF2prst=0] ScOP @e[c=1,r=1,TF2Projectile,TF2prst=0] TF2Nom = @e[c=1,r=1,TF2Projectile,TF2prst=0] TF2Denom
	@e[TF2Projectile,TF2prst=0] TF2Denom + 324000000
	ScOP @e[TF2Projectile,TF2prst=0] TF2Nom *= -4 Number
	@e[TF2Projectile,TF2prst=0] TF2Nom + 324000000
	ScOP @e[TF2Projectile,TF2prst=0] TF2Denom /= 1000 Number
	@e[TF2Projectile,TF2prst=0] ScOP @e[c=1,r=1,TF2Projectile,TF2prst=0] TF2Nom /= @e[c=1,r=1,TF2Projectile,TF2prst=0] TF2Denom
	@e[TF2Projectile,TF2prst=0] ScOP @e[c=1,r=1,TF2Projectile,TF2prst=0] TF2CosT = @e[c=1,r=1,TF2Projectile,TF2prst=0] TF2Nom
	@e[TF2Projectile,TF2prst=0] ScOP @e[c=1,r=1,TF2Projectile,TF2prst=0] TF2CosT *= @e[c=1,r=1,TF2Projectile,TF2prst=0] TF2Neg
/// RotationDisplay(5)
//>

//<Upon Weapon Fire: Calculating X, Y and Z coordinates
/// X - sin(theta)sin(phi)
	@e[TF2Projectile,TF2prst=0] ScOP @e[c=1,r=1,TF2Projectile,TF2prst=0] TF2X = @e[c=1,r=1,TF2Projectile,TF2prst=0] TF2SinP
	@e[TF2Projectile,TF2prst=0] ScOP @e[c=1,r=1,TF2Projectile,TF2prst=0] TF2X *= @e[c=1,r=1,TF2Projectile,TF2prst=0] TF2SinT
	@e[TF2Projectile,TF2prst=0] ScOP @e[c=1,r=1,TF2Projectile,TF2prst=0] TF2X *= @e[c=1,r=1,TF2Projectile,TF2prst=0] TF2Rad

/// Y - cos(theta)
	@e[TF2Projectile,TF2prst=0] ScOP @e[c=1,r=1,TF2Projectile,TF2prst=0] TF2Y = @e[c=1,r=1,TF2Projectile,TF2prst=0] TF2CosP
	ScOP @e[TF2Projectile,TF2prst=0] TF2Y *= 1000 Number
	@e[TF2Projectile,TF2prst=0] ScOP @e[c=1,r=1,TF2Projectile,TF2prst=0] TF2Y *= @e[c=1,r=1,TF2Projectile,TF2prst=0] TF2Rad
	
/// Z - sin(theta)cos(phi)
	@e[TF2Projectile,TF2prst=0] ScOP @e[c=1,r=1,TF2Projectile,TF2prst=0] TF2Z = @e[c=1,r=1,TF2Projectile,TF2prst=0] TF2SinP
	@e[TF2Projectile,TF2prst=0] ScOP @e[c=1,r=1,TF2Projectile,TF2prst=0] TF2Z *= @e[c=1,r=1,TF2Projectile,TF2prst=0] TF2CosT
	@e[TF2Projectile,TF2prst=0] ScOP @e[c=1,r=1,TF2Projectile,TF2prst=0] TF2Z *= @e[c=1,r=1,TF2Projectile,TF2prst=0] TF2Rad
//>

//<Upon Weapon Fire: Other
/// Various scoreboards
	@a[TF2CS>=1] TF2CS = 0
	@e[TF2Projectile,TF2prst=0] TF2IA = 1
	@e[TF2Projectile,TF2prst=0] TF2Roll = 0
	
	ScOP @e[TF2Projectile,TF2prst=0] TF2Rev = Bounce TF2Edit
	@e[TF2Projectile,TF2prst=0,TF2Rev<=0] TF2Rev = -1
	@e[TF2Projectile,TF2prst=0,TF2Rev>=1] TF2Rev = 0
	@e[TF2Projectile,TF2prst=0,TF2Rev=0] TF2GravT = -1
	$s$tp @e[TF2Projectile,TF2prst=0] ~ ~0.720 ~

/// RotationDisplay
/// CalcDisplay
/// XYZDisplay

	@e[TF2Projectile,TF2prst=0] TF2prst = 1
//>


//<Motion clock: Start
:CBPMotion CLOCK $Style$
	testfor @e[TF2Projectile,TF2prst=1]
	SetblockTestfor
	@e[TF2Projectile,TF2prst=1] TF2time + 1
	
/// Adjusting movement speeds
///	If the abs(movement speed) is too high (20,000,000 or 20000000), reset back
	@e[TF2Projectile,TF2prst=1,TF2X>=20000000] TF2X = 20000000
	@e[TF2Projectile,TF2prst=1,TF2X<=-20000000] TF2X = -20000000
	@e[TF2Projectile,TF2prst=1,TF2Y>=20000000] TF2Y = 20000000
	@e[TF2Projectile,TF2prst=1,TF2Y<=-20000000] TF2Y = -20000000
	@e[TF2Projectile,TF2prst=1,TF2Z>=20000000] TF2Z = 20000000
	@e[TF2Projectile,TF2prst=1,TF2Z<=-20000000] TF2Z = -20000000
	
///	Rolling check
	ScOP @e[TF2Projectile,TF2prst=1,TF2Rev=0,TF2Roll>=1] TF2GenC = Bounce TF2Edit
	ScOP @e[TF2Projectile,TF2prst=1,TF2Rev=0,TF2Roll>=1,TF2GenC=1] TF2GenC = Gravity TF2Edit
	@e[TF2Projectile,TF2prst=1,TF2Rev=0,TF2Roll=1,TF2GenC<=-1] TF2Roll = 0
	@e[TF2Projectile,TF2prst=1,TF2Rev=0,TF2Roll=2,TF2GenC>=1] TF2Roll = 0
	@e[TF2Projectile,TF2prst=1,TF2Rev=0,TF2Roll>=1,TF2GenC=0] TF2Roll = 0
	@e[TF2Projectile,TF2prst=1,TF2Rev=0,TF2Roll=1] air -1 ~ ~0.7 ~ @e[c=1,r=1,TF2Projectile,TF2prst=1,TF2Rev=0,TF2Roll=1] TF2Roll = 0
	@e[TF2Projectile,TF2prst=1,TF2Rev=0,TF2Roll=2] air -1 ~ ~1.3 ~ @e[c=1,r=1,TF2Projectile,TF2prst=1,TF2Rev=0,TF2Roll=2] TF2Roll = 0
	
///	Bounce check
	ScOP @e[TF2Projectile,TF2prst=1] TF2GenC = Bounce TF2Edit
	@e[TF2Projectile,TF2prst=1,TF2Rev=-1,TF2GenC=1] TF2Rev = 0
	@e[TF2Projectile,TF2prst=1,TF2Rev=0,TF2GenC=0] TF2Rev = -1
	@e[TF2Projectile,TF2prst=1] TF2GenC = 0
	
/// Gravity
/// @e[TF2Projectile,TF2prst=1,TF2Rev<=0,TF2Roll=0] ScOP @e[c=1,r=1,TF2Projectile,TF2prst=1,TF2Rev<=0,TF2Roll=0] TF2GC = @e[c=1,r=1,TF2Projectile,TF2prst=1,TF2Rev<=0,TF2Roll=0] TF2GravT
/// @e[TF2Projectile,TF2prst=1,TF2Rev<=0,TF2Roll=0] TF2GravT + 1
/// ScOP @e[TF2Projectile,TF2prst=1,TF2Rev<=0,TF2IA=1,TF2GravT>=1,TF2Roll=0] TF2GC *= Gravity TF2Edit
	
	@e[TF2Projectile,TF2prst=1,TF2Rev<=0,TF2Roll=0] TF2GravT + 1
	ScOP @e[TF2Projectile,TF2prst=1,TF2Rev<=0,TF2IA=1,TF2GravT>=1,TF2Roll=0] TF2Y -= Gravity TF2Edit
	
///	Rolling friction - Calculate percentage
///	Negative - negative, positive - positive = easy af
	@e[TF2Projectile,TF2prst=1,TF2Rev=0,TF2Roll>=1] ScOP @e[c=1,r=1,TF2Projectile,TF2prst=1,TF2Rev=0,TF2Roll>=1] TF2RollCX = @e[c=1,r=1,TF2Projectile,TF2prst=1,TF2Rev=0,TF2Roll>=1] TF2X
	ScOP @e[TF2Projectile,TF2prst=1,TF2Rev=0,TF2Roll>=1] TF2RollCX /= RollCoefficient TF2Edit
	@e[TF2Projectile,TF2prst=1,TF2Rev=0,TF2Roll>=1] ScOP @e[c=1,r=1,TF2Projectile,TF2prst=1,TF2Rev=0,TF2Roll>=1] TF2X -= @e[c=1,r=1,TF2Projectile,TF2prst=1,TF2Rev=0,TF2Roll>=1] TF2RollCX
	
	@e[TF2Projectile,TF2prst=1,TF2Rev=0,TF2Roll>=1] ScOP @e[c=1,r=1,TF2Projectile,TF2prst=1,TF2Rev=0,TF2Roll>=1] TF2RollCZ = @e[c=1,r=1,TF2Projectile,TF2prst=1,TF2Rev=0,TF2Roll>=1] TF2Z
	ScOP @e[TF2Projectile,TF2prst=1,TF2Rev=0,TF2Roll>=1] TF2RollCZ /= RollCoefficient TF2Edit
	@e[TF2Projectile,TF2prst=1,TF2Rev=0,TF2Roll>=1] ScOP @e[c=1,r=1,TF2Projectile,TF2prst=1,TF2Rev=0,TF2Roll>=1] TF2Z -= @e[c=1,r=1,TF2Projectile,TF2prst=1,TF2Rev=0,TF2Roll>=1] TF2RollCZ
	
///	Resetting X and Z scores to 0 if they are too small - Applies only for rolling
	
	-Change LowVelocityCheck to set to 0 when the entire XZ vector goes too low
	
	
	
	
	
	@e[TF2Projectile,TF2prst=1,TF2Rev=0,TF2Roll>=1] ScOP @e[c=1,r=1,TF2Projectile,TF2prst=1,TF2Rev=0,TF2Roll>=1] TF2LVC = @e[c=1,r=1,TF2Projectile,TF2prst=1,TF2Rev=0,TF2Roll>=1] TF2X
	ScOP @e[TF2Projectile,TF2prst=1,TF2Rev=0,TF2Roll>=1,TF2LVC<=-1] TF2LVC *= -1 Number
	ScOP @e[TF2Projectile,TF2prst=1,TF2Rev=0,TF2Roll>=1,TF2LVC>=1] TF2LVC -= LowVelocityCheck TF2Edit
	@e[TF2Projectile,TF2prst=1,TF2Rev=0,TF2Roll>=1,TF2LVC<=-1] TF2X = 0
	
	@e[TF2Projectile,TF2prst=1,TF2Rev=0,TF2Roll>=1] ScOP @e[c=1,r=1,TF2Projectile,TF2prst=1,TF2Rev=0,TF2Roll>=1] TF2LVC = @e[c=1,r=1,TF2Projectile,TF2prst=1,TF2Rev=0,TF2Roll>=1] TF2Z
	ScOP @e[TF2Projectile,TF2prst=1,TF2Rev=0,TF2Roll>=1,TF2LVC<=-1] TF2LVC *= -1 Number
	ScOP @e[TF2Projectile,TF2prst=1,TF2Rev=0,TF2Roll>=1,TF2LVC>=1] TF2LVC -= LowVelocityCheck TF2Edit
	@e[TF2Projectile,TF2prst=1,TF2Rev=0,TF2Roll>=1,TF2LVC<=-1] TF2Z = 0
	
///	Setting the motion scores
	@e[TF2Projectile,TF2prst=1,TF2Rev<=2] ScOP @e[c=1,r=1,TF2Projectile,TF2prst=1,TF2Rev<=2] TF2XT = @e[c=1,r=1,TF2Projectile,TF2prst=1,TF2Rev<=2] TF2X
	@e[TF2Projectile,TF2prst=1,TF2Rev<=2,TF2Roll=0] ScOP @e[c=1,r=1,TF2Projectile,TF2prst=1,TF2Rev<=2,TF2Roll=0] TF2YT = @e[c=1,r=1,TF2Projectile,TF2prst=1,TF2Rev<=2,TF2Roll=0] TF2Y
/// @e[TF2Projectile,TF2prst=1,TF2Rev<=2,TF2Roll=0] ScOP @e[c=1,r=1,TF2Projectile,TF2prst=1,TF2Rev<=2,TF2Roll=0] TF2YT -= @e[c=1,r=1,TF2Projectile,TF2prst=1,TF2Rev<=2,TF2Roll=0] TF2GC
	@e[TF2Projectile,TF2prst=1,TF2Rev<=2] ScOP @e[c=1,r=1,TF2Projectile,TF2prst=1,TF2Rev<=2] TF2ZT = @e[c=1,r=1,TF2Projectile,TF2prst=1,TF2Rev<=2] TF2Z
	ScOP @e[TF2Projectile,TF2prst=1,TF2Rev=2] TF2XT *= -1 Number
	ScOP @e[TF2Projectile,TF2prst=1,TF2Rev=2] TF2YT *= -1 Number
	ScOP @e[TF2Projectile,TF2prst=1,TF2Rev=2] TF2ZT *= -1 Number
	@e[TF2Projectile,TF2prst=1,TF2Rev=2] TF2Rev = 1	
//>
	
//<Motion clock Func Repeat: Block Collision
FUNC RepeatProjectileCollision
///	Block collision
	@e[TF2Projectile,TF2prst=1,TF2Rev<=1] TF2IA = 0
	@e[TF2Projectile,TF2prst=1,TF2IA=0,TF2Rev<=1] air -1 ~ ~1 ~ @e[TF2Projectile,TF2prst=1,c=1,r=0] TF2IA = 1
///	@e[TF2Projectile,TF2prst=1,TF2IA=0,TF2Rev<=1] tallgrass -1 ~ ~1 ~ @e[TF2Projectile,TF2prst=1,c=1,r=0] TF2IA = 1
///	@e[TF2Projectile,TF2prst=1,TF2IA=0,TF2Rev<=1] double_plant -1 ~ ~1 ~ @e[TF2Projectile,TF2prst=1,c=1,r=0] TF2IA = 1
///	@e[TF2Projectile,TF2prst=1,TF2IA=0,TF2Rev<=1] air -1 ~ ~1.3 ~ @e[TF2Projectile,TF2prst=1,c=1,r=0] wooden_slab -1 ~ ~1 ~ @e[TF2Projectile,TF2prst=1,c=1,r=0] TF2IA = 1
///	@e[TF2Projectile,TF2prst=1,TF2IA=0,TF2Rev<=1] air -1 ~ ~1.3 ~ @e[TF2Projectile,TF2prst=1,c=1,r=0] stone_slab -1 ~ ~1 ~ @e[TF2Projectile,TF2prst=1,c=1,r=0] TF2IA = 1
	@e[TF2Projectile,TF2prst=1,TF2IA=1,TF2Rev=1] TF2Rev = 3
	@e[TF2Projectile,TF2prst=1,TF2IA=0,TF2Rev=1] TF2IA = 1
	@e[TF2Projectile,TF2prst=1,TF2IA=1,TF2Rev<=1] particle mobSpell ~ ~1 ~ 1 -1 0 10 0 force
END
//>

//<Motion clock Func Repeat: Teleports
FUNC RepeatProjectileTeleport
///	Bulk motion
$s$tp @e[TF2Projectile,TF2prst=1,TF2XT>=2000000,TF2IA=1,TF2Rev<=1] ~0.200 ~ ~
CONDITION
	@e[TF2Projectile,TF2prst=1,TF2XT>=2000000,TF2IA=1,TF2Rev<=1] TF2XT - 2000000
	
$s$tp @e[TF2Projectile,TF2prst=1,TF2XT<=-2000000,TF2IA=1,TF2Rev<=1] ~-0.200 ~ ~
CONDITION
	@e[TF2Projectile,TF2prst=1,TF2XT<=-2000000,TF2IA=1,TF2Rev<=1] TF2XT + 2000000
	
$s$tp @e[TF2Projectile,TF2prst=1,TF2YT>=2000000,TF2IA=1,TF2Rev<=1] ~ ~0.200 ~
CONDITION
	@e[TF2Projectile,TF2prst=1,TF2YT>=2000000,TF2IA=1,TF2Rev<=1] TF2YT - 2000000
	
$s$tp @e[TF2Projectile,TF2prst=1,TF2YT<=-2000000,TF2IA=1,TF2Rev<=1] ~ ~-0.200 ~
CONDITION
	@e[TF2Projectile,TF2prst=1,TF2YT<=-2000000,TF2IA=1,TF2Rev<=1] TF2YT + 2000000
	
$s$tp @e[TF2Projectile,TF2prst=1,TF2ZT>=2000000,TF2IA=1,TF2Rev<=1] ~ ~ ~0.200
CONDITION
	@e[TF2Projectile,TF2prst=1,TF2ZT>=2000000,TF2IA=1,TF2Rev<=1] TF2ZT - 2000000
	
$s$tp @e[TF2Projectile,TF2prst=1,TF2ZT<=-2000000,TF2IA=1,TF2Rev<=1] ~ ~ ~-0.200
CONDITION
	@e[TF2Projectile,TF2prst=1,TF2ZT<=-2000000,TF2IA=1,TF2Rev<=1] TF2ZT + 2000000
END
//>

//<Motion clock: Applying the Functions
LOOP 1 9 + 1
	RepeatProjectileTeleport
	RepeatProjectileCollision
END
//>

//<Motion clock: Fine movement
	LOOP 128 1 / 2
		$s$tp @e[TF2Projectile,TF2prst=1,TF2IA=1,TF2XT>=|0|0000,TF2Rev<=1] ~DIV(|0|;1000.0) ~ ~
		CONDITION
			@e[TF2Projectile,TF2prst=1,TF2IA=1,TF2XT>=|0|0000,TF2Rev<=1] TF2XT - |0|0000
		$s$tp @e[TF2Projectile,TF2prst=1,TF2IA=1,TF2XT<=-|0|0000,TF2Rev<=1] ~-DIV(|0|;1000.0) ~ ~
		CONDITION
			@e[TF2Projectile,TF2prst=1,TF2IA=1,TF2XT<=-|0|0000,TF2Rev<=1] TF2XT + |0|0000
	END
	LOOP 128 1 / 2
		$s$tp @e[TF2Projectile,TF2prst=1,TF2IA=1,TF2YT>=|0|0000,TF2Rev<=1] ~ ~DIV(|0|;1000.0) ~
		CONDITION
			@e[TF2Projectile,TF2prst=1,TF2IA=1,TF2YT>=|0|0000,TF2Rev<=1] TF2YT - |0|0000
		$s$tp @e[TF2Projectile,TF2prst=1,TF2IA=1,TF2YT<=-|0|0000,TF2Rev<=1] ~ ~-DIV(|0|;1000.0) ~
		CONDITION
			@e[TF2Projectile,TF2prst=1,TF2IA=1,TF2YT<=-|0|0000,TF2Rev<=1] TF2YT + |0|0000
	END
	LOOP 128 1 / 2
		$s$tp @e[TF2Projectile,TF2prst=1,TF2IA=1,TF2ZT>=|0|0000,TF2Rev<=1] ~ ~ ~DIV(|0|;1000.0)
		CONDITION
			@e[TF2Projectile,TF2prst=1,TF2IA=1,TF2ZT>=|0|0000,TF2Rev<=1] TF2ZT - |0|0000
		$s$tp @e[TF2Projectile,TF2prst=1,TF2IA=1,TF2ZT<=-|0|0000,TF2Rev<=1] ~ ~ ~-DIV(|0|;1000.0)
		CONDITION
			@e[TF2Projectile,TF2prst=1,TF2IA=1,TF2ZT<=-|0|0000,TF2Rev<=1] TF2ZT + |0|0000
	END

RepeatProjectileCollision
//>

//<Motion Clock: Bounce
///	TF2IAC is in case it thinks it hits a block when it's actually in the air, normally caused by going through chunks.
	$s$kill @e[TF2Projectile,TF2prst=1,TF2IA=0,TF2Rev=-1]
	@e[TF2Projectile,TF2prst=1,TF2IA=0,TF2Rev=0] TF2Rev = 2
//>

//<Motion clock: Time
	ScOP @e[TF2Projectile,TF2prst=1] TF2timeC = Time TF2Edit
	@e[TF2Projectile,TF2prst=1] ScOP @e[TF2Projectile,TF2prst=1,c=1,r=1] TF2timeC -= @e[TF2Projectile,TF2prst=1,c=1,r=1] TF2time
	$s$kill @e[TF2Projectile,TF2prst=1,TF2timeC<=0]
	
	scoreboard players test KillAll TF2Edit 1 1
	CONSTART
		KillAll TF2Edit = 0
		$s$kill @e[type=ArmorStand,TF2Projectile]
	CONEND
//>


//<Bounce clock: Scoreboard resetting
:CBPBounce CLOCK $Style$
	testfor @e[TF2Projectile,TF2Rev=3]
	SetblockTestfor
///	TF2Rev -1 = does not bounce
///	TF2Rev 0 = bouncing projectile in the air
///	TF2Rev 2 = Temp change (0 - 2) to reverse all x,y,z velocity vectors
///	TF2Rev 1 = Temp change (2 - 1) to teleport the projectile out of the block
///	TF2Rev 3 = Change (1 - 3) when out of the air, activates bounce clock and all movement is seized
/// @e[TF2Projectile,TF2prst=1,TF2Rev=3] ScOP @e[TF2Projectile,TF2prst=1,TF2Rev=3,c=1,r=1] TF2Y -= @e[TF2Projectile,TF2prst=1,TF2Rev=3,c=1,r=1] TF2GC
	
	@e[TF2Projectile,TF2prst=1,TF2Rev=3] TF2NAX = 0
	@e[TF2Projectile,TF2prst=1,TF2Rev=3] TF2NAY = 0
	@e[TF2Projectile,TF2prst=1,TF2Rev=3] TF2NAZ = 0
	@e[TF2Projectile,TF2prst=1,TF2Rev=3] TF2NADPX = 0
	@e[TF2Projectile,TF2prst=1,TF2Rev=3] TF2NADPY = 0
	@e[TF2Projectile,TF2prst=1,TF2Rev=3] TF2NADPZ = 0
	@e[TF2Projectile,TF2prst=1,TF2Rev=3] TF2NADNX = 0
	@e[TF2Projectile,TF2prst=1,TF2Rev=3] TF2NADNY = 0
	@e[TF2Projectile,TF2prst=1,TF2Rev=3] TF2NADNZ = 0
//>

//<Bounce clock: Directional scoreboard setting
///	Detection of planes
	@e[TF2Projectile,TF2prst=1,TF2Rev=3] air -1 ~0.3 ~1 ~ @e[TF2Projectile,TF2prst=1,TF2Rev=3,c=1,r=0] TF2NAX + 1
	@e[TF2Projectile,TF2prst=1,TF2Rev=3] air -1 ~-0.3 ~1 ~ @e[TF2Projectile,TF2prst=1,TF2Rev=3,c=1,r=0] TF2NAX + 1
	
	@e[TF2Projectile,TF2prst=1,TF2Rev=3] air -1 ~ ~1.3 ~ @e[TF2Projectile,TF2prst=1,TF2Rev=3,c=1,r=0] TF2NAY + 1
	@e[TF2Projectile,TF2prst=1,TF2Rev=3] air -1 ~ ~0.7 ~ @e[TF2Projectile,TF2prst=1,TF2Rev=3,c=1,r=0] TF2NAY + 1
	
	@e[TF2Projectile,TF2prst=1,TF2Rev=3] air -1 ~ ~1 ~0.3 @e[TF2Projectile,TF2prst=1,TF2Rev=3,c=1,r=0] TF2NAZ + 1
	@e[TF2Projectile,TF2prst=1,TF2Rev=3] air -1 ~ ~1 ~-0.3 @e[TF2Projectile,TF2prst=1,TF2Rev=3,c=1,r=0] TF2NAZ + 1

///	Activates only if everywhere detected is air: For diagonals
///	Uses this part for when the projectile hits an edge or a corner rather than a flat plane or an indoor corner
///	Corners are the only ones detected
	@e[TF2Projectile,TF2prst=1,TF2Rev=3,TF2NAX=2,TF2NAY=2,TF2NAZ=2] air -1 ~0.3 ~1.3 ~0.3 @e[TF2Projectile,TF2prst=1,TF2Rev=3,c=1,r=0] TF2NADPX + 1
	@e[TF2Projectile,TF2prst=1,TF2Rev=3,TF2NAX=2,TF2NAY=2,TF2NAZ=2] air -1 ~0.3 ~1.3 ~0.3 @e[TF2Projectile,TF2prst=1,TF2Rev=3,c=1,r=0] TF2NADPY + 1
	@e[TF2Projectile,TF2prst=1,TF2Rev=3,TF2NAX=2,TF2NAY=2,TF2NAZ=2] air -1 ~0.3 ~1.3 ~0.3 @e[TF2Projectile,TF2prst=1,TF2Rev=3,c=1,r=0] TF2NADPZ + 1
	
	@e[TF2Projectile,TF2prst=1,TF2Rev=3,TF2NAX=2,TF2NAY=2,TF2NAZ=2] air -1 ~0.3 ~0.7 ~0.3 @e[TF2Projectile,TF2prst=1,TF2Rev=3,c=1,r=0] TF2NADPX + 1
	@e[TF2Projectile,TF2prst=1,TF2Rev=3,TF2NAX=2,TF2NAY=2,TF2NAZ=2] air -1 ~0.3 ~0.7 ~0.3 @e[TF2Projectile,TF2prst=1,TF2Rev=3,c=1,r=0] TF2NADNY + 1
	@e[TF2Projectile,TF2prst=1,TF2Rev=3,TF2NAX=2,TF2NAY=2,TF2NAZ=2] air -1 ~0.3 ~0.7 ~0.3 @e[TF2Projectile,TF2prst=1,TF2Rev=3,c=1,r=0] TF2NADPZ + 1
	
	@e[TF2Projectile,TF2prst=1,TF2Rev=3,TF2NAX=2,TF2NAY=2,TF2NAZ=2] air -1 ~0.3 ~1.3 ~-0.3 @e[TF2Projectile,TF2prst=1,TF2Rev=3,c=1,r=0] TF2NADPX + 1
	@e[TF2Projectile,TF2prst=1,TF2Rev=3,TF2NAX=2,TF2NAY=2,TF2NAZ=2] air -1 ~0.3 ~1.3 ~-0.3 @e[TF2Projectile,TF2prst=1,TF2Rev=3,c=1,r=0] TF2NADPY + 1
	@e[TF2Projectile,TF2prst=1,TF2Rev=3,TF2NAX=2,TF2NAY=2,TF2NAZ=2] air -1 ~0.3 ~1.3 ~-0.3 @e[TF2Projectile,TF2prst=1,TF2Rev=3,c=1,r=0] TF2NADNZ + 1
	
	@e[TF2Projectile,TF2prst=1,TF2Rev=3,TF2NAX=2,TF2NAY=2,TF2NAZ=2] air -1 ~0.3 ~0.7 ~-0.3 @e[TF2Projectile,TF2prst=1,TF2Rev=3,c=1,r=0] TF2NADPX + 1
	@e[TF2Projectile,TF2prst=1,TF2Rev=3,TF2NAX=2,TF2NAY=2,TF2NAZ=2] air -1 ~0.3 ~0.7 ~-0.3 @e[TF2Projectile,TF2prst=1,TF2Rev=3,c=1,r=0] TF2NADNY + 1
	@e[TF2Projectile,TF2prst=1,TF2Rev=3,TF2NAX=2,TF2NAY=2,TF2NAZ=2] air -1 ~0.3 ~0.7 ~-0.3 @e[TF2Projectile,TF2prst=1,TF2Rev=3,c=1,r=0] TF2NADNZ + 1
	
	@e[TF2Projectile,TF2prst=1,TF2Rev=3,TF2NAX=2,TF2NAY=2,TF2NAZ=2] air -1 ~-0.3 ~1.3 ~-0.3 @e[TF2Projectile,TF2prst=1,TF2Rev=3,c=1,r=0] TF2NADNX + 1
	@e[TF2Projectile,TF2prst=1,TF2Rev=3,TF2NAX=2,TF2NAY=2,TF2NAZ=2] air -1 ~-0.3 ~1.3 ~-0.3 @e[TF2Projectile,TF2prst=1,TF2Rev=3,c=1,r=0] TF2NADPY + 1
	@e[TF2Projectile,TF2prst=1,TF2Rev=3,TF2NAX=2,TF2NAY=2,TF2NAZ=2] air -1 ~-0.3 ~1.3 ~-0.3 @e[TF2Projectile,TF2prst=1,TF2Rev=3,c=1,r=0] TF2NADNZ + 1
	
	@e[TF2Projectile,TF2prst=1,TF2Rev=3,TF2NAX=2,TF2NAY=2,TF2NAZ=2] air -1 ~-0.3 ~0.7 ~-0.3 @e[TF2Projectile,TF2prst=1,TF2Rev=3,c=1,r=0] TF2NADNX + 1
	@e[TF2Projectile,TF2prst=1,TF2Rev=3,TF2NAX=2,TF2NAY=2,TF2NAZ=2] air -1 ~-0.3 ~0.7 ~-0.3 @e[TF2Projectile,TF2prst=1,TF2Rev=3,c=1,r=0] TF2NADNY + 1
	@e[TF2Projectile,TF2prst=1,TF2Rev=3,TF2NAX=2,TF2NAY=2,TF2NAZ=2] air -1 ~-0.3 ~0.7 ~-0.3 @e[TF2Projectile,TF2prst=1,TF2Rev=3,c=1,r=0] TF2NADNZ + 1
	
	@e[TF2Projectile,TF2prst=1,TF2Rev=3,TF2NAX=2,TF2NAY=2,TF2NAZ=2] air -1 ~-0.3 ~1.3 ~0.3 @e[TF2Projectile,TF2prst=1,TF2Rev=3,c=1,r=0] TF2NADNX + 1
	@e[TF2Projectile,TF2prst=1,TF2Rev=3,TF2NAX=2,TF2NAY=2,TF2NAZ=2] air -1 ~-0.3 ~1.3 ~0.3 @e[TF2Projectile,TF2prst=1,TF2Rev=3,c=1,r=0] TF2NADPY + 1
	@e[TF2Projectile,TF2prst=1,TF2Rev=3,TF2NAX=2,TF2NAY=2,TF2NAZ=2] air -1 ~-0.3 ~1.3 ~0.3 @e[TF2Projectile,TF2prst=1,TF2Rev=3,c=1,r=0] TF2NADPZ + 1
	
	@e[TF2Projectile,TF2prst=1,TF2Rev=3,TF2NAX=2,TF2NAY=2,TF2NAZ=2] air -1 ~-0.3 ~0.7 ~0.3 @e[TF2Projectile,TF2prst=1,TF2Rev=3,c=1,r=0] TF2NADNX + 1
	@e[TF2Projectile,TF2prst=1,TF2Rev=3,TF2NAX=2,TF2NAY=2,TF2NAZ=2] air -1 ~-0.3 ~0.7 ~0.3 @e[TF2Projectile,TF2prst=1,TF2Rev=3,c=1,r=0] TF2NADNY + 1
	@e[TF2Projectile,TF2prst=1,TF2Rev=3,TF2NAX=2,TF2NAY=2,TF2NAZ=2] air -1 ~-0.3 ~0.7 ~0.3 @e[TF2Projectile,TF2prst=1,TF2Rev=3,c=1,r=0] TF2NADNZ + 1
//>

//<Bounce clock: Reversing direction
///	Reversing only when there is 1 detected air block in the X,Y,Z direction
	ScOP @e[TF2Projectile,TF2prst=1,TF2Rev=3,TF2NAX=1] TF2X *= -1 Number
	ScOP @e[TF2Projectile,TF2prst=1,TF2Rev=3,TF2NAY=1] TF2Y *= -1 Number
	ScOP @e[TF2Projectile,TF2prst=1,TF2Rev=3,TF2NAZ=1] TF2Z *= -1 Number
	
///	Start off as reversed when the normal detection everywhere is air
	ScOP @e[TF2Projectile,TF2prst=1,TF2Rev=3,TF2NAX=2,TF2NAY=2,TF2NAZ=2] TF2X *= -1 Number
	ScOP @e[TF2Projectile,TF2prst=1,TF2Rev=3,TF2NAX=2,TF2NAY=2,TF2NAZ=2] TF2Y *= -1 Number
	ScOP @e[TF2Projectile,TF2prst=1,TF2Rev=3,TF2NAX=2,TF2NAY=2,TF2NAZ=2] TF2Z *= -1 Number
	
///	When Pos X,Y,Z and Neg X,Y,Z are both equal to three (detects air), then reverse
	ScOP @e[TF2Projectile,TF2prst=1,TF2Rev=3,TF2NAX=2,TF2NAY=2,TF2NAZ=2,TF2NADPX=3,TF2NADNX=3] TF2X *= -1 Number
	ScOP @e[TF2Projectile,TF2prst=1,TF2Rev=3,TF2NAX=2,TF2NAY=2,TF2NAZ=2,TF2NADPY=3,TF2NADNY=3] TF2Y *= -1 Number
	ScOP @e[TF2Projectile,TF2prst=1,TF2Rev=3,TF2NAX=2,TF2NAY=2,TF2NAZ=2,TF2NADPZ=3,TF2NADNZ=3] TF2Z *= -1 Number
	
///	TF2Roll
///	Keep original angle in a scoreboard
///	Whenever X or Z are reflected, change original angle
///	Keep track if X or Z is reflected by a seperate scoreboard (TF2RevX, TF2RevZ)
///	Translate the angles if reflected
///	Once angle is translated, set as original angle
///	Used the angle to calculate sin(theta) and cos(theta)
///	Multiply the sin/cos values by custom value to get x and y rolling reduction constant
///	Use TF2RevY as well as TF2Y to determine when it is capable of rolling
//>

//<Bounce Clock: Friction calculations, rolling and resetting
	ScOP @e[TF2Projectile,TF2prst=1,TF2Rev=3] TF2X *= FrictionNumXZ TF2Edit
	ScOP @e[TF2Projectile,TF2prst=1,TF2Rev=3] TF2X /= FrictionDenXZ TF2Edit
	ScOP @e[TF2Projectile,TF2prst=1,TF2Rev=3] TF2Y *= FrictionNumY TF2Edit
	ScOP @e[TF2Projectile,TF2prst=1,TF2Rev=3] TF2Y /= FrictionDenY TF2Edit
	ScOP @e[TF2Projectile,TF2prst=1,TF2Rev=3] TF2Z *= FrictionNumXZ TF2Edit
	ScOP @e[TF2Projectile,TF2prst=1,TF2Rev=3] TF2Z /= FrictionDenXZ TF2Edit
	
///	calculates x/sin(theta) and x/cos(theta), averages - gets h
///	multiply h by FrictionNumXZ/FrictionDenXZ
	
///	Rolling
	@e[TF2Projectile,TF2prst=1,TF2Rev=3] ScOP @e[c=1,r=1,TF2Projectile,TF2prst=1,TF2Rev=3] TF2RollC = @e[c=1,r=1,TF2Projectile,TF2prst=1,TF2Rev=3] TF2Y
	ScOP @e[TF2Projectile,TF2prst=1,TF2Rev=3,TF2RollC<=-1] TF2RollC *= -1 Number
	ScOP @e[TF2Projectile,TF2prst=1,TF2Rev=3,TF2RollC>=1] TF2RollC -= RollVelocityCheck TF2Edit
	@e[TF2Projectile,TF2prst=1,TF2Rev=3,TF2RollC>=0] TF2RollC = 0
	@e[TF2Projectile,TF2prst=1,TF2Rev=3,TF2RollC<=-1] TF2RollC = 1
	
	ScOP @e[TF2Projectile,TF2prst=1,TF2Rev=3,TF2RollC=1] TF2RollC = Bounce TF2Edit
	ScOP @e[TF2Projectile,TF2prst=1,TF2Rev=3,TF2RollC=1] TF2RollC = Gravity TF2Edit
	@e[TF2Projectile,TF2prst=1,TF2Rev=3,TF2RollC>=1] TF2Roll = 1
	@e[TF2Projectile,TF2prst=1,TF2Rev=3,TF2RollC<=-1] TF2Roll = 2
	@e[TF2Projectile,TF2prst=1,TF2Rev=3,TF2Roll=1] air -1 ~ ~0.7 ~ @e[c=1,r=1,TF2Projectile,TF2prst=1,TF2Rev=3,TF2Roll=1] TF2Roll = 0
	@e[TF2Projectile,TF2prst=1,TF2Rev=3,TF2Roll=2] air -1 ~ ~1.3 ~ @e[c=1,r=1,TF2Projectile,TF2prst=1,TF2Rev=3,TF2Roll=2] TF2Roll = 0
	
	@e[TF2Projectile,TF2prst=1,TF2Rev=3,TF2Roll>=1<=2] TF2Y = 0
	
///	X
/// @e[TF2Projectile,TF2prst=1,TF2Rev=3,TF2Roll=-1] ScOP @e[c=1,r=1,TF2Projectile,TF2prst=1,TF2Rev=3,TF2Roll=-1] TF2RollCX = @e[c=1,r=1,TF2Projectile,TF2prst=1,TF2Rev=3,TF2Roll=-1] TF2SinT
/// ScOP @e[TF2Projectile,TF2prst=1,TF2Rev=3,TF2Roll=-1,TF2RollCX<=-1] TF2RollCX *= -1 Number
/// ScOP @e[TF2Projectile,TF2prst=1,TF2Rev=3,TF2Roll=-1,TF2RollCX>=0] TF2RollCX *= RollCoefficient TF2Edit
	
///	Z
/// @e[TF2Projectile,TF2prst=1,TF2Rev=3,TF2Roll=-1] ScOP @e[c=1,r=1,TF2Projectile,TF2prst=1,TF2Rev=3,TF2Roll=-1] TF2RollCZ = @e[c=1,r=1,TF2Projectile,TF2prst=1,TF2Rev=3,TF2Roll=-1] TF2CosT
/// ScOP @e[TF2Projectile,TF2prst=1,TF2Rev=3,TF2Roll=-1,TF2RollCZ<=-1] TF2RollCZ *= -1 Number
/// ScOP @e[TF2Projectile,TF2prst=1,TF2Rev=3,TF2Roll=-1,TF2RollCZ>=0] TF2RollCZ *= RollCoefficient Number
	
	@e[TF2Projectile,TF2prst=1,TF2Rev=3] TF2GravT = 0
///	@e[TF2Projectile,TF2prst=1,TF2Rev=3] TF2RevC + 1
	
	@e[TF2Projectile,TF2prst=1,TF2Rev=3] TF2Rev = 0
	
	-Bounce is odd with negative gravity
		-When it bounces off a wall at the apex of the arc when gravity is negative, goes into rolling mode
//>












